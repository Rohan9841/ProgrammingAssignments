/**
*Name: Rohan Maharjan
*Course: CSCI 3005
*Instructor: Dr. Cordova
**/

/**
   *importing java packages
*/
import java.util.*;
import java.io.*;

/**
   *The WordPairs class contains methods that uses Breadth first search algorithm to perform 
   *various operations on a graph of word pairs. The graph is generated by using a helper class
   *'Digraph.java' which is provided by the instructor. The 'Digraph.java' class have methods that
   *allow user to add vertices and edges to the graph and display them as well. It also contains 
   *method to display all the children of a particular vertex.Our 'WordPairs.java' class uses
   *it to create a graph containing all the words that are in the files provided by the instructor.
   *This program can be used to generate chain of pairs of words starting and ending at the user
   *defined words. It can also provide us with the total number of those pairs. Similarly, we can
   *find all or partial vertices that can be reached from a particular word. 
*/

public class WordPairs
{
    /**
      instance variable to store file that is to be read
   **/  
   String fileToRead;
   
    /**
      instance variable to store the pair of words generated by wordChain method.
   **/
   String blockChain;
   
    /**
      object of the DiGraph class that will be used to access methods from the Digraph class
   **/
   DiGraph g;
   
    /**
      instance variable to store the total number of words that can be reached from a particular word
   **/
   int NumOfWords;
   
    /**
      map object to store height of the graph as key, and the set of all the words in that height as value
   **/
   Map<Integer,Collection<String>> trackWordsMap;
   
    /**
      map object to store a word as key, and the list of all its parents as value 
   **/
   Map<String,List<String>> parentsMap;
   
   /**
      Argument constructor that will scan through the file passed as its argument and use digraph
      class to generate graph of all the word-pairs in that file.
      @param fileName This is the name of the file from which we can get our data. 
   **/  
   public WordPairs(String fileName)
   {
      //The array will contain the two words from each line of the fileName
      String[] wordArray = new String[2];
      
      //instantiating the DiGraph class
      g = new DiGraph();
     
      //assigning our instance variable to the name of the fileName
      fileToRead = fileName;
     
      //Scanning through the file
      try
      {
         File infile = new File(fileToRead);
        
         Scanner in = new Scanner(infile);
        
         while (in.hasNextLine())
         {
            String sentence = in.nextLine();
           
           //During each iteration wordArray will have two values
            wordArray = sentence.split(" ");
           
           //Adding the first value of the wordArray as a vertex
            g.addVertex(wordArray[0]);
            
            //Adding the second value of the wordArray as a vertex
            g.addVertex(wordArray[1]);
            
            //Adding an edge between first and second value of the wordArray
            g.addEdge(wordArray[0],wordArray[1]);
         }
      }
      
      //If there is no such file
      catch (FileNotFoundException exc)
      {
         System.out.println("File not found.");
      }
   }
   
     
   /**
      Method to return the shortest sequence of word pairs that begins with the first and ends
      with last using the format as follows: [first word1,word2 word3,word3...wordn,wordn last]
      @param first The word sequence will start from this word
      @param last The word sequence will end in this word
      @return The shortest sequence of word pairs starting at first and ending at last. If there 
      is no such sequence, returns []
   **/
   public String wordChain (String first, String last)
   {
      //calling BreadthFirst method which will update the value of blockChain and store all the required word pairs
      BreadthFirst(first, last,-1);
      
      //if blockChain does not contain any word pairs
      if(blockChain =="")
      {
         return ("[]");
      }
      return blockChain;
   }
   
   /**
      Method to return the number of word pairs in the shortest chain that begins with first and 
      ends with last
      @param first The word sequence will start from this word
      @param last The word sequence will end in this word
      @return The total number of word pairs in the shortest chain. If there is no such chain, returns 
      maximum integer value
   **/
   public int chainLength(String first, String last)
   {
      //calling BreadthFirst method which will update the value of blockChain and store all the required word pairs
      BreadthFirst(first, last,-1);
      
      //if blockChain contains word pairs
      if(!blockChain.equals(""))
      {
         //splitting the blockChain and storing its contents in an array
         String[] pairArray = blockChain.split(","); 
         
         //return the length of the array
         return(pairArray.length);  
      }
      //if the blockChain doesn't contain word pairs, returns the maximum integer value
      return Integer.MAX_VALUE;
   }   
   
   /**
      Method to return the number of distinct words that are part of all chains that begin with word 
      @param word The word becomes the root of the graph. 
      @return The total number of words that can be reached from the root in the graph
   **/ 
   public int reachableFrom(String word)
   {
      //calling BreadthFirst method which will update the value of NumOfWords.
      BreadthFirst(word,null,-1);
      return NumOfWords-1; 
   }
   
    /**
      Method to return the number of distinct words that are part of all chains of maxLength that begin with word 
      @param word The word becomes the root of the graph
      @param maxLength The total level of the graph that the method can traverse 
      @return The total number of words within the maxLength level that can be reached from the root in the graph 
   **/
   public int reachableFrom(String word, int maxLength)
   {
      //Checking if maxLength is equal to or greater than root level
      if(maxLength >= 0)
      {
         //calling BreadthFirst method which will update the value of NumOfWords
         BreadthFirst(word,null,maxLength);
         
         //One is deducted from NumOfWords because one extra node is traversed before the program stops.
         return (NumOfWords-1);
      }
      //if maxLength is smaller than root level, return 0
      return 0;
   }
   
    /**
      Method to return a String containing the distinct words that are part of all chains of maxLength
      that begin with word. The reachable words should be grouped by level 
      @param word The word becomes the root of the graph. 
      @maxLength The total level of the graph that the method can traverse
      @return All the words within the maxLength level that can be reached from the root in the graph and separated based on their levels
   **/
   public String reachableWords(String word, int maxLength)
   {
      //Variable to store the words within the maxLength that are reachable 
      String result = "";
      
      //checking if the maxLength is equal to or greater than the root level
      if(maxLength >= 0)
      {
         //calling BreadthFirst method which will update the value of trackWordsMap
         BreadthFirst(word,null,maxLength);
         
         //looping through the required keys in the trackWordsMap
         for(int i = 0; i<=maxLength; i++)
         {
            //Concatenating result with the value obtained from the map
               result += trackWordsMap.get(i) + "\n";
         }
         return result;
      }
      
      //if the maxLength is smaller than root level 
      return "[]";
   }
   
   /**
      Method to return the shortest sequence of word pairs that begins and ends with word, using
      the format as follows: [word word1,word2 word3,word3...wordn,wordn word]
      @param word The word pair will start from this word and end at the same word
      @return The shortest sequence of word pairs starting and ending at word. If there 
      is no such sequence, returns []
   **/

   public String cycle(String word)
   {
      //calling BreadthFirst method which will update the value of blockChain and store all the required word pairs
      BreadthFirst(word,word,-1); 
      
      //if there are no word pairs
      if(blockChain =="")
      {
         return ("[]");
      }
      
      //if the blockChain contains word pairs
      return blockChain;
   
   }
   
   /**
      Helper method to add a word to a list and return the word pairs by formatting that list 
      @param word This word will be added to the list
      @param x This list will contain all the parents of a word
      @return The all the word pairs which are generated by formatting the list
   **/
   private String makeBlockChain(String word, List x)
   {
      //Variable to store the formatted word pair
      String chain = "";
      
      //adding the word to the list
      x.add(word);
      
      //for all the elements in the list                  
      for(int i = 0; i<x.size()-1; i++)
      {
         //formatting the String 'chain'
         chain+= x.get(i)+" "+x.get(i+1)+",";
      }
      //formatting the string
      chain = "["+chain.substring(0,chain.length()-1)+"]";
      
      return chain;
   
   }
   
   /**
      Helper method that contains all the important logic to run the program.The graph will be traversed
      starting from first and ending at last.
      @param first This will be the root of the graph
      @param last The traversing of the graph stops when the last is found
      @param maxLength The graph will be traversed upto the maxLength level
   **/
   private void BreadthFirst(String first, String last, int maxLength)
   {
      //NumOfWords is set to 1 because a word can always be reached from itself
      NumOfWords = 1;
      
      //instantiating blockchain as an empty string
      blockChain = "";
      
      //Instantiating a queue which will be used to add and remove the word 
      Queue<String> queue = new LinkedList<String>();
      
      //The parentsMap will contain the list that contains all the parents of all node. Key: children, Value: Parents      
      parentsMap = new HashMap<String,List<String>>();
      
      //The trackWordsMap will contain a tree set that contains all the nodes in all level. Key: level, Value: all nodes in that level
      trackWordsMap = new HashMap<Integer,Collection<String>>();
      
      //The visitetList contains a set of all the words that have been visited
      Set<String> visitedList = new HashSet<String>();
      
      //The parentList contains the list of all the parents of a particular node. 
      List<String> parentList = new ArrayList<String>();
      
      //The levelList contains set of all words in a particular level
      Collection<String> levelList = new TreeSet<String>();
      
      //Validity check
      if(g.validVertex(first) && (g.validVertex(last)||last==null))
      {  
         //if first and last words are same than do not add the first word in the visited list
         if(!first.equals(last))
         {   
            visitedList.add(first);
         }
         
         //adidng first word in the visited list   
         queue.add(first);
         
         //mapping first word to the empty parentList         
         parentsMap.put(first,parentList);
         
         //This will be used to keep track of size of parentList
         int sizeCounter = 0;
         
         //adding first word to the levelList
         levelList.add(first);
         
         //mapping level 0 to levelList which contains the first word   
         trackWordsMap.put(parentList.size(),levelList);
         
         //The loop will run for both maxLength<0 and maxLength>=0.
         while (!queue.isEmpty() && ((parentList.size()<=maxLength)||(maxLength<0)))
         {  
            //wordToRemove will get the words removed from the queue    
            String wordToRemove = queue.remove();
            
            //if the first word is equal to the last word
            if(first.equals(last))
            {
               //if the visited list contains first word(IMPORTANT: first = last, so first has not been added to the visited list)
               if(visitedList.contains(first))
               {
                  //instantiate an arrayList which will contain copy of a parentsList mapped from parentsMap, that contains all the parents of the first word
                  List<String> chainList = new ArrayList<String>(parentsMap.get(first));
                  
                  //calling blockChain method that will format the list and give us the word pairs
                  blockChain = makeBlockChain(first, chainList);
                  
                  //break out of the while loop once we find the first word in the visited list
                  break;
               }   
            }
            
            //if the first word and last word are different
            else
            {
               //if we find the last word while traversing the graph
               if(wordToRemove.equals(last))
               {
                  //instantiate an arrayList which contains copy of parentsList mapped from parentsMap, that contains all the parents of the last word
                  List<String> chainList = new ArrayList<String>(parentsMap.get(wordToRemove));
                  
                  //calling blockChain method that will format the list and give us the word pairs
                  blockChain = makeBlockChain(wordToRemove,chainList);
                  
                  //break out of the while loop once we find the last word
                  break;
               }
            }
            
            //This will iterate through all the children of wordToRemove                           
            Iterator<String> iterator = g.getAdjacent(wordToRemove).iterator();  
            
            //while there is children and (maxLength (>= || <) 0)       
            while (iterator.hasNext() && ((parentList.size()<=maxLength)||(maxLength<0)))
            {                  
               String iteratedWord = iterator.next();
               
               //if the child is not in the visited list   
               if(!visitedList.contains(iteratedWord))
               {
                  
                  //instantiate a new parentList with copy of the list of all parents of 'wordToRemove'
                  parentList = new ArrayList<String>(parentsMap.get(wordToRemove));
                  
                  //add 'wordToRemove' to the parentList
                  parentList.add(wordToRemove);
                  
                  //if the size of the parentList is increased, we know that the we are traversing through the next level of the graph   
                  if(parentList.size() > sizeCounter)
                  {
                     //instantiate a new levelList 
                     levelList = new TreeSet<String>();
                     
                     //increase sizeCounter so that it can always keep up with the size of the parentList
                     sizeCounter++;
                  }
                  
                  //add the child to the levelList   
                  levelList.add(iteratedWord);
                  
                  //add the child to the visitedList
                  visitedList.add(iteratedWord);
                  
                  //add the child to the queue
                  queue.add(iteratedWord);
                  
                  //map the child to its parentList
                  parentsMap.put(iteratedWord, parentList);
                  
                  //increase the number of visited nodes by 1
                  NumOfWords += 1;
               }
               
                  
            }
            
            //mapping each level to all the words in that level   
            trackWordsMap.put(parentList.size(),levelList);
               
         }
         
         //It's possible that the program has traversed all the nodes, but the maxLength is greater than parentsList. So, we need to traverse through the level which is not even there.
         if(maxLength > parentList.size())
         {
            //From the level which we haven't traversed in the graph to the level of maxLength, add empty list to the trackWordsMap
            for(int i = parentList.size()+1;i<=maxLength;i++)
            {
               trackWordsMap.put(i,new TreeSet<String>());
            }
         }
         
         //if queue is empty, we are not adding extra height. However, we always return (NumOfWords-1) in ReachableFrom method which will give us one less node. 
         if(queue.isEmpty())
         {
            //adding one to the total number of nodes
            NumOfWords += 1;
            
            
         }
      }
   }

}